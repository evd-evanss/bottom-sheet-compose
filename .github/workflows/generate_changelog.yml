name: Generate Changelog and Post Review Comments

on:
  pull_request:
    types: [opened, synchronize, reopened]

jobs:
  generate_and_review:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write # Necessário para adicionar comentários de revisão e atualizar o corpo do PR

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Necessário para git diff

      - name: Get PR Diff Text for AI
        id: get_pr_diff_text
        run: |
          BASE_SHA=${{ github.event.pull_request.base.sha }}
          HEAD_SHA=${{ github.event.pull_request.head.sha }}
          
          echo "Base SHA: $BASE_SHA"
          echo "Head SHA: $HEAD_SHA"

          # Obter o diff completo para a IA
          # Não vamos truncar agressivamente aqui, pois a IA precisa do contexto.
          # A IA é quem vai gerenciar o tamanho da entrada que ela pode processar.
          DIFF_OUTPUT=$(git diff --unified=3 $BASE_SHA $HEAD_SHA) # Usar diff unificado com 3 linhas de contexto

          # Escapar para JSON
          JSON_SAFE_DIFF=$(echo "$DIFF_OUTPUT" | sed 's/\\/\\\\/g' | sed 's/"/\\"/g' | sed ':a;N;$!ba;s/\n/\\n/g')

          echo "diff_for_ai<<EOF" >> $GITHUB_OUTPUT
          echo "$JSON_SAFE_DIFF" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
        shell: bash

      - name: Call Gemini API for Review and Summary
        id: call_gemini
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          COMMIT_DIFF_TEXT: ${{ steps.get_pr_diff_text.outputs.diff_for_ai }}
        run: |
          # Prompt para gerar sugestões de revisão em JSON e um resumo para o corpo do PR
          PROMPT="Você é um assistente de revisão de código e gerador de changelog.
          Analise o seguinte diff de um Pull Request.

          Seu output DEVE CONTER DUAS PARTES PRINCIPAIS:
          1. Uma chave JSON chamada \"review_suggestions\" contendo um array de objetos.
          2. Uma chave JSON chamada \"pull_request_summary\" contendo uma string de texto para o resumo do PR.

          Formato JSON esperado para a saída completa:
          {
            \"review_suggestions\": [
              {
                \"file_path\": \"caminho/para/o/arquivo.ext\",
                \"line_number_hint\": \"Número da linha aproximado no arquivo APÓS a mudança, ou um trecho de código alterado para ajudar a localizar. Ex: 15 ou 'if (condicao) {'\",
                \"suggestion_text\": \"Sua sugestão de melhoria aqui.\"
              }
              // ... mais sugestões
            ],
            \"pull_request_summary\": \"**Resumo das Alterações (Gerado por IA):**\n- Mudança A...\n- Correção B...\"
          }

          Para \"review_suggestions\":
          - Priorize problemas como: bugs, erros de lógica, código redundante, comentários desnecessários, melhorias de legibilidade.
          - Se nenhum problema for encontrado, \"review_suggestions\" deve ser um array vazio [].
          - Seja conciso e direto nas sugestões.

          Para \"pull_request_summary\":
          - Gere um breve descritivo das principais funcionalidades adicionadas, corrigidas ou impactos.
          - Use bullet points se apropriado. Foque no 'o quê' e 'porquê' da mudança para um changelog.

          Diff:
          $COMMIT_DIFF_TEXT"

          JSON_PAYLOAD=$(cat <<EOF
          {
            "contents": [{
              "parts": [{
                "text": "$PROMPT"
              }]
            }],
            "generationConfig": {
              "temperature": 0.5, # Temperatura mais baixa para respostas mais factuais/estruturadas
              "maxOutputTokens": 1500, # Aumentado para acomodar JSON e resumo
              "responseMimeType": "application/json" # Pedir JSON diretamente
            }
          }
          EOF
          )

          API_URL="https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=$GEMINI_API_KEY"
          
          RESPONSE_BODY_FILE=$(mktemp)
          HTTP_STATUS=$(curl -s -w "%{http_code}" -o "$RESPONSE_BODY_FILE" \
            -X POST "$API_URL" \
            -H "Content-Type: application/json" \
            -d "$JSON_PAYLOAD")

          RAW_RESPONSE_TEXT=$(cat "$RESPONSE_BODY_FILE")
          rm "$RESPONSE_BODY_FILE"

          echo "Gemini API HTTP Status: $HTTP_STATUS"
          echo "Gemini API Raw Response: $RAW_RESPONSE_TEXT"

          if [ "$HTTP_STATUS" -ne 200 ]; then
            echo "::error::Falha na chamada da API Gemini. Status: $HTTP_STATUS. Resposta: $RAW_RESPONSE_TEXT"
            # Fornecer fallback estruturado
            GENERATED_JSON_OUTPUT='{"review_suggestions":[], "pull_request_summary":"**Resumo das Alterações (Gerado por IA):**\nFalha ao comunicar com a IA."}'
          else
            # Tentar extrair o JSON da resposta. A API Gemini com responseMimeType: application/json
            # às vezes ainda envolve o JSON em